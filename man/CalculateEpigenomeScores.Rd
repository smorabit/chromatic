% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/scoring.R
\name{CalculateEpigenomeScores}
\alias{CalculateEpigenomeScores}
\title{CalculateEpigenomeScores}
\usage{
CalculateEpigenomeScores(
  seurat_obj,
  chromHMM_states,
  stoplist = NULL,
  remove_nonstandard_chromosomes = TRUE,
  filter_features = TRUE,
  min_cells = 100,
  min_counts = 100,
  state_signs = NULL,
  covariates = NULL,
  state_col = "name",
  active_patterns = c("TssA", "TssFlnk", "Tx", "EnhA", "EnhG", "EnhWk"),
  repressive_patterns = c("ReprPC", "Quies", "Het"),
  pseudocount = 0.5,
  assay = "ATAC"
)
}
\arguments{
\item{seurat_obj}{Seurat object containing scATAC-seq data. Must have peaks as
features (rows) and cells as columns in the \code{assay} specified.}

\item{chromHMM_states}{A \code{GenomicRanges} object containing ChromHMM state annotations.
Should have a column with state labels specified by \code{state_col}.}

\item{stoplist}{(Optional) A \code{GenomicRanges} object of regions to exclude (e.g. blacklisted regions).
If provided, peaks overlapping these regions will be removed.}

\item{remove_nonstandard_chromosomes}{Logical; if TRUE (default), non-standard chromosomes
(e.g. scaffolds) will be removed from both peaks and chromHMM annotations.}

\item{filter_features}{Logical; if TRUE (default), peaks are filtered to exclude features
with low coverage using \code{ExcludeUncommonPeaks}.}

\item{min_cells}{Integer; minimum number of cells required for a peak to be kept
(passed to \code{ExcludeUncommonPeaks}).}

\item{min_counts}{Integer; minimum total counts required for a peak to be kept
(passed to \code{ExcludeUncommonPeaks}).}

\item{state_signs}{Named vector indicating the “sign” (active/repressive) of each chromatin state.
If NULL (default), will be generated automatically from \code{chromHMM_states} using
\code{ChromatinStateSigns()} and the patterns provided.}

\item{covariates}{(Optional) Character vector of covariate column names from
\code{seurat_obj@meta.data} to regress out from the scores (e.g. TSS.enrichment, nCount_ATAC).}

\item{state_col}{Character; name of the metadata column in \code{chromHMM_states} containing the state label.}

\item{active_patterns}{Character vector of patterns used to identify active states
(passed to \code{ChromatinStateSigns()}). Default includes "TssA", "TssFlnk", "Tx", "EnhA", "EnhG", "EnhWk".}

\item{repressive_patterns}{Character vector of patterns used to identify repressive states
(passed to \code{ChromatinStateSigns()}). Default includes "ReprPC", "Quies", "Het".}

\item{pseudocount}{Numeric; pseudocount to add before calculating fractions
(used by scoring functions). Default = 0.5.}

\item{assay}{Character; name of the Seurat assay containing scATAC data. Default = 'ATAC'.}
}
\value{
A list containing:
\describe{
\item{peaks_gr}{\code{GenomicRanges} of the filtered and annotated peaks.}
\item{state_matrix}{Matrix of chromatin-state fractions per cell (rows = cells, cols = states).}
\item{erosion}{Data frame of erosion scores per cell (optionally covariate-regressed).}
\item{entropy}{Data frame of entropy-based plasticity scores per cell (optionally covariate-regressed).}
}
}
\description{
A wrapper function to compute chromatin-state–based scores from scATAC-seq data
stored in a Seurat object. This function:
(1) annotates peaks with ChromHMM states,
(2) filters peaks and sets up a chromatin state matrix per cell,
(3) calculates an erosion score (active vs. repressive balance), and
(4) calculates an entropy-based plasticity score.
}
\details{
This function orchestrates several steps:
\itemize{
\item Annotates each ATAC peak with its overlapping ChromHMM state.
\item Filters peaks to remove blacklisted/nonstandard regions and optionally low-coverage peaks.
\item Constructs a cell-by-state matrix (fraction of accessibility per state per cell).
\item Computes an erosion score (active vs. repressive chromatin balance).
\item Computes an entropy-based plasticity score (degree of state heterogeneity per cell).
}

The helper functions \code{AnnotatePeaks}, \code{ExcludeUncommonPeaks},
\code{ChromatinStateSigns}, \code{CalculateStateMatrix}, \code{ErosionScore}, and
\code{EntropyScore} must be defined and return objects in the expected format.
}
\examples{
\dontrun{
scores <- CalculateEpigenomeScores(
    seurat_obj = atac_seurat,
    chromHMM_states = chromHMM_mouse,
    stoplist = blacklist_gr,
    covariates = c("TSS.enrichment","nCount_ATAC")
)
}

}
